# 模糊查询
## 关键字 LIKE

##### LIKE后面跟上匹配语句
##### %:表示后面的任意字符(0-多个)
##### _:表示任意一个字符
	-- 查询所有姓马的员工
	SELECT * FROM emp WHERE NAME LIKE '马%';
	
	-- 查询姓名当中包含'小'的员工
	
	SELECT * FROM emp WHERE NAME LIKE '%小%';
	
	-- 查询姓马，且名字只有两个字的员工
	SELECT * FROM emp WHERE NAME LIKE '马__';

# 聚合函数
## 聚合函数的作用就是对一组数据进行统计的聚合，最后返回一个值
##### COUNT:统计一组数据的具体记录数
	-- 查询出我一共有多少个商品
	SELECT COUNT(*) AS 商品总数 FROM pric;

##### MAX:统计一组数据的最大值
	-- 查询所有商品最高价格
	SELECT MAX(pric) FROM pric;

##### MIN:统计一组数据的最小值
	-- 查询商品的最小价格
	SELECT MIN(pric) FROM pric;

##### SUM:统计一组数据的总和
	-- 查询商品价格的总和
	SELECT SUM(pric) FROM pric;

##### AVG:统计一组数据的平均值
	-- 查询商品价格的平均值
	SELECT AVG(pric) FROM pric;


	-- 查询商品的最小价格/最大价格以及商品的成本价格总和
	SELECT MIN(pric),MAX(pric),SUM(pric) FROM pric;

>  查询商品的记录数，在Java当中进行接收一定要使用long类型
>  COUNT会自动排除NULL值的数据

# 分页查询
## 假分页/逻辑分页/内存分页
	一次性从数据查询出所有的数据，将这些数据存放在内存当中(List的集合当中)，每一次翻页的时候都从内存去取出数据。
	特点:翻页速度非常快，但是每一次断点都需要从数据库重新取出数据，而且极容易造成内存溢出。
## 真分页/物理分页/数据库分页
	每一次翻页的时候，都从数据库截取指定的条数，比如0-9/10-19....
	特点:如果每页显示的数据非常多，速度会比较慢，但是不会造成内存溢出

## MySQL的分页
### LIMIT 从多少行开始查询,每一次查询执行多少行;
	
	-- 第一页
	SELECT * FROM emp LIMIT 0,3; 
	-- 第二页
	SELECT * FROM emp LIMIT 3,3; 
	-- 第三页
	SELECT * FROM emp LIMIT 6,3; 

	-- Java中如何利用分页的规则
	-- int pageSize = 3;//每一页显示的数量
	-- int currentPage = 1;//当前页数
	SELECT * FROM emp LIMIT (currentPage-1)*pageSize,pageSize; 

# 分组查询
## 统计各个区的人数是多少[GROUP BY]
	SELECT AREA AS 地区,COUNT(*)AS 人数 FROM emp GROUP BY AREA;
## 查询工资大于2000的人数[GROUP BY]
	SELECT sal AS 工资,COUNT(*)AS 人数 FROM emp WHERE sal > 2000 GROUP BY AREA;
## 查询人数大余2个人的地区(HAVING)
	SELECT `area`,COUNT(*) FROM `emp` GROUP BY `area` HAVING COUNT(*) > 2;

	-- 错误代码
	SELECT AREA,COUNT(*) FROM EMP WHERE COUNT(*) > 2 GROUP BY AREA;
	
## 员工工资从小到大进行排序(默认缺省值)[ORDER BY]
	SELECT * FROM emp ORDER BY sal ASC;

## 员工工资从大到小进行排序[ORDER BY]
	SELECT * FROM emp ORDER BY sal DESC;
	
####   执行顺序:FROM -> WHERE -> SELECT -> GROUP BY

###  HAVING和WHERE的区别?
#### HAVING是分组后的条件刷选，主要使用在GROUP BY子句后面
#### WHERE是分组钱的条件刷选，主要使用在GROUP BY子句执行的前面
-----
# 数据库的设计
### 需求分析:原始需求(啥都不懂的客户提出来的)
### 业务需求:登录需要几张表？几个字段?字段类型？字段长度？

## 数据库的三大范式设计(是每一个程序员必须掌握和了解的数据库设计的最基础的理念)
## 第一范式:每一张表的字段名都必须是具备原子性（每一个字段都必须是一个不可分割的单元）
### 违背第一范式
	+---------------------------------+
			id				name
	+---------------------------------+
			1			toobug | 张飞龙
			2			   张三|二狗子
	+---------------------------------+
	查询现用名姓张的学生 张%
### 符合第一范式
	+---------------------------------+
			id		name	old_name
	+---------------------------------+
			1		toobug 	张飞龙
			2		张三		二狗子
	+---------------------------------+

## 第二范式:在第一范式的基础上，要求表除主键字段以外的字段必须和该表存在绝对的依赖关系
### 违反第二方式
	+---------------------------------+
			id		姓名		 订单
	+---------------------------------+
			1		toobug 	 001
			2		张三		 002
	+---------------------------------+

### 符合第二范式
	-- 员工表
	+---------------------------------+
			id			姓名		
	+---------------------------------+
			1			toobug 	 
			2			张三		 
	+---------------------------------+
	-- 订单表
	+---------------------------------+
			id			订单		
	+---------------------------------+
			1			001 	 
			2			002		 
	+---------------------------------+


## 第三范式:在第二范式的基础上，要求表除主键字段以外的字段只能和主键有直接决定的依赖关系
### 违反第三范式
	-- 员工表
	+---------------------------------+
			id		姓名			部门	
	+---------------------------------+
			1		toobug 	 软件开发部
			2		张三		 软件开发部
			3		张三		 软件开发部
			4		张三		 软件开发部
	+---------------------------------+

### 符合第三范式
		-- 员工表
	+---------------------------------+
			id		姓名			部门	
	+---------------------------------+
			1		toobug 	 	1
			2		张三		 	1
			3		张三		 	1
			4		张三		 	1
	+---------------------------------+

		-- 部门表
	+---------------------------------+
			id			姓名				
	+---------------------------------+
			1			软件开发部 	 
			2			基础架构部		 
			3			视图处理部		 
	+---------------------------------+

----
# 数据的约束
## 给表添加一些数据上面的条件约束，主要的作用就是约束用户对数据操作的准确性

### 默认值约束[DEFAULT]
#### 当前表在某个字段没有插入数据的时候，可以适当的赋予默认的插入
> 默认约束必须是插入字段没有插入值的时候才会生效

> 需求:当gender字段没被插入数据的时候，默认显示女
	CREATE TABLE test(
	NAME VARCHAR(20),
	gender VARCHAR(2) DEFAULT '女'
	);
	
	INSERT INTO test(NAME,gender) VALUE('toobug','男');
	INSERT INTO test(NAME) VALUE('橘梨纱');

### 非空约束[NOT NULL]
#### 当在某个字段限制非空约束的时候，以后再任何情况，该字段必须存在数据，不能是NULL

	CREATE TABLE test(
	NAME VARCHAR(20) NOT NULL,
	gender VARCHAR(2)
	);
	
	INSERT INTO test(NAME,gender) VALUE('toobug','男');
	INSERT INTO test(gender) VALUE('女'); -- 违反约束

### 唯一约束[UNIQUE]
#### 某个字段被限制唯一约束之后，该字段的数据值必须是唯一不重复的，否则将违反约束
	-- 唯一约束
	CREATE TABLE test(
		id INT UNIQUE,
		NAME VARCHAR(20) NOT NULL,
		gender VARCHAR(2)
	);
	
	INSERT INTO test(ID,NAME,gender) VALUE(1,'toobug','男');
	INSERT INTO test(ID,NAME,gender) VALUE(1,'','女'); -- 违反约束

###主键约束(重要[非空+唯一])[PRIMARY KEY]
####1.通常只在创建一个表的时候，我们都会加上一个id的字段，这个字段的本意就是保证每一条数据的准确性和唯一性(唯一、非空)，所以我们需要使用主键
####2.我们一般设置主键的方式有两种，一直被称之为业务主键，一种被称之为自然主键
##### 业务主键:通常使用某个业务字段作为主键参考(name/sid/password)
##### 自然主键:通常使用一个无意义的字段，自然生长 不去干预（id）
##### 在实际的开发当中，我们尽可能不去使用业务字段作为表主键，因为业务的需求变化太大，一旦业务需求更改，也就意味着表主键失效，业务字段很容易出现字段重复的问题
##### 我们推荐的方式，一般是给每一张表设定一个id字段，这个字段不存在任何的业务意义，而且这个字段最好是自增长
	
	-- 主键约束
	CREATE TABLE test(
		id INT PRIMARY KEY,
		NAME VARCHAR(20),
		gender VARCHAR(2)
	);
	
	
	INSERT INTO test(ID,NAME,gender) VALUE(1,'toobug','男');


###外键约束(重要)[PRIMARY KEY]
###什么情况下需要使用到外键约束？
####当我们存在两张或两张表以上的时候，且这张表的某个字段密切关联着另外一张表的数据，则需要使用到外键约束
#### 什么情况下可能会出现两张表？
##### 出现数据冗余的时候
	-- 员工表
	CREATE TABLE employee(
		id  INT PRIMARY KEY AUTO_INCREMENT,
		NAME VARCHAR(20),
		deptid INT,
		-- constraint 外键名称 foreign key(外键字段) references 主键表(主键表字段);	
		CONSTRAINT fk_dept_emp FOREIGN KEY(deptid) REFERENCES detp(id)
	)

-- 创建一个商品表和分类表
----
# 多表之间的建表原则
## 一对多:商品和分类
> 建表原则:在多一方建立外键，在一的一方建立主键，使用外键关联主键

## 多对多:老师和学生，学生和课程
> 建表原则:建立一张中间表，将多对多的关系拆成一对多的关系，中间表最少要有两个外键
> 
## 一对一:班级和班长，一个公民对应一个身份证
> 将一对一的关系，直接当成是一条数据进行处理，或者说直接当成一对多的关系也没问题，但凡一张表只要包含主键，那么就是一对一的关系

## 多表查询
	-- 交叉查询造成了笛卡尔积查询(左表数据 * 右表数据 = 结果数据)
	SELECT * FROM emp,detp;
	-- 解决笛卡尔积的问题(内连接查询) 使用最多的
	SELECT e.name,d.dname FROM emp e,detp d WHERE e.id = d.id;
	
	-- 内连接查询方式二
	SELECT 
		e.name,d.dname 
	FROM  
		emp e
	INNER JOIN 
		dept d
	ON 
		e.id = d.id;
	
	-- 左外连接查询
	-- 以左表作为显示主体，右边的显示数量将参考左表进行显示
		-- 研发部 toobug
		-- 技术部 mayun
		-- 研发部 null
	SELECT d.dname,e.name
		FROM detp d
		LEFT OUTER JOIN	emp e
		ON d.id = e.id;
	

	-- 右外连接查询
	-- 以右表作为显示主体，左边的显示数量将参考右表进行显示
		-- 研发部 toobug
		-- 技术部 mayun
		-- 研发部 null
	SELECT e.name,d.dname
		FROM detp d
		RIGHT OUTER JOIN emp e
		ON d.id = e.id;
		
	-- 子查询
	SELECT * FROM emp WHERE id = 4;
	
	-- 查询大于公司平均工资的员工姓名
	-- 计算平均工资
	    SELECT AVG(sal) FROM emp;
	-- 计算大于平均工资的员工
	SELECT NAME,sal FROM emp WHERE sal > (SELECT AVG(sal) FROM emp);
	
	-- 计算出工资比马云还要高的员工
	SELECT sal FROM emp WHERE NAME = '马云';
	
	SELECT * FROM emp WHERE sal > (SELECT sal FROM emp WHERE NAME = '马云');


	-- 查询每个部门的部门编号，总人数，平均工资
	-- 查询与TOOBUG在同一个部门的员工
	-- 查询工资比马马云少的员工所在部门的人数
	-- 查询每个部门薪水最高的员工所有信息
	-- 查询所有部门编号为2的员工信息

	-- 设计表
	-- 账号
	-- 商品
	-- 分类
	-- 要求商品必须存在由哪个账户进行发布的
